#!/usr/bin/env python3
"""
АНАЛИЗ КОЭФФИЦИЕНТА C=1 В ЧЛЕНЕ 1/(π⁴·S²)

Цель: Понять, почему C ≈ 1 (оптимальное C = 0.9936).

Метод: Исследование 2-loop структуры и геометрических инвариантов.

Навигация:
  ← 13_casimir_explicit.py | README.md →
  Главная: 00_main.md
"""

from mpmath import mp, pi, zeta as mpzeta, log, exp, sqrt
mp.dps = 80

print("="*70)
print("АНАЛИЗ КОЭФФИЦИЕНТА C=1")
print("="*70)

# =============================================================================
# §1. ИСХОДНЫЕ ДАННЫЕ
# =============================================================================

print("\n§1. Исходные данные")
print("-"*40)

S_geo = 4*pi**3 + pi**2 + pi
alpha_codata = mp.mpf('137.035999177')
sigma = mp.mpf('0.000000085')

# 1-loop поправка
delta_24 = 1 / (24 * S_geo)

# Без 2-loop
alpha_no_2loop = S_geo - delta_24
diff_no_2loop = alpha_no_2loop - alpha_codata

print(f"S_geo = {float(S_geo):.12f}")
print(f"α⁻¹ (без 2-loop) = {float(alpha_no_2loop):.12f}")
print(f"Разница = {float(diff_no_2loop):.2e}")
print(f"В сигмах = {float(diff_no_2loop/sigma):.1f}σ")

# Оптимальный C
C_opt = float((S_geo - delta_24 - alpha_codata) * pi**4 * S_geo**2)
print(f"\nОптимальный C = {C_opt:.10f}")
print(f"Отклонение от 1: {(C_opt - 1)*100:.4f}%")

# =============================================================================
# §2. ГИПОТЕЗА: C = 1 ИЗ НОРМИРОВКИ
# =============================================================================

print("\n§2. Гипотеза: C из нормировки детерминантов")
print("-"*40)

print("""
В 2-loop приближении:
  Γ^(2) = (1/2!) × (Γ^(1))² × (топ. фактор)

Если учесть оба сектора (бозон + фермион):
  - Бозонный вклад: +1/2 × (...)²
  - Фермионный вклад: -1/2 × (...)² (знак минус от Грассмана)
  
Сумма: может давать C = 1 при определённой комбинации.
""")

# 2-loop коэффициенты
c_boson = mp.mpf('0.5')  # 1/2!
c_fermion = mp.mpf('-0.5')  # -1/2! (Грассман)

print(f"Бозонный вклад: {float(c_boson)}")
print(f"Фермионный вклад: {float(c_fermion)}")
print(f"Сумма: {float(c_boson + c_fermion)} (взаимно уничтожаются!)")

# Но это означает, что 2-loop = 0, не 1
print("\n→ Простое сложение даёт 0, не 1. Нужен другой механизм.")

# =============================================================================
# §3. ГИПОТЕЗА: C = 1 ИЗ ГЕОМЕТРИИ Vol²
# =============================================================================

print("\n§3. Гипотеза: C = Vol(RP³)²/π⁴")
print("-"*40)

Vol_RP3 = pi**2
Vol_RP3_squared = Vol_RP3**2

print(f"Vol(RP³) = π² = {float(Vol_RP3):.10f}")
print(f"Vol(RP³)² = π⁴ = {float(Vol_RP3_squared):.10f}")
print(f"π⁴ = {float(pi**4):.10f}")
print(f"Отношение = {float(Vol_RP3_squared / pi**4):.10f}")

print("""
Ключевое наблюдение:
  π⁴ = (π²)² = Vol(RP³)²

Поэтому член 1/π⁴ — это 1/Vol²!

Размерный анализ:
  δ^(2) ~ 1/Vol² × (геом. инвариант)
  
Если геом. инвариант = 1 (безразмерная единица), то C = 1.
""")

# =============================================================================
# §4. ГИПОТЕЗА: C ИЗ ДЗЕТА-ФУНКЦИИ
# =============================================================================

print("\n§4. Гипотеза: C через ζ(4)")
print("-"*40)

zeta_4 = mpzeta(4)
print(f"ζ(4) = π⁴/90 = {float(zeta_4):.15f}")
print(f"π⁴/90 = {float(pi**4/90):.15f}")

# Что если C = 90/ζ(4)?
C_from_zeta = 90 * zeta_4 / pi**4
print(f"90×ζ(4)/π⁴ = {float(C_from_zeta):.10f}")

# Что если использовать ζ(4)/S² напрямую?
delta_zeta4 = zeta_4 / S_geo**2
alpha_zeta4 = S_geo - delta_24 - delta_zeta4
diff_zeta4 = (alpha_zeta4 - alpha_codata) / sigma
print(f"\nС δ = ζ(4)/S²: отклонение = {float(diff_zeta4):.1f}σ (хуже!)")

# =============================================================================
# §5. ИССЛЕДОВАНИЕ БЛИЗКИХ ЗНАЧЕНИЙ C
# =============================================================================

print("\n§5. Исследование значений C вблизи 1")
print("-"*40)

print("C\t\tα⁻¹\t\t\tΔσ")
print("-"*50)

for C_test in [0.99, 0.993, 0.9936, 0.994, 0.995, 1.0, 1.005, 1.01]:
    delta_2loop = C_test / (pi**4 * S_geo**2)
    alpha_test = S_geo - delta_24 - delta_2loop
    diff_sigma = float((alpha_test - alpha_codata) / sigma)
    print(f"{C_test:.4f}\t\t{float(alpha_test):.12f}\t{diff_sigma:+.2f}σ")

# =============================================================================
# §6. СТРУКТУРА ОПТИМАЛЬНОГО C
# =============================================================================

print("\n§6. Структура оптимального C")
print("-"*40)

print(f"C_opt = {C_opt:.15f}")

# Проверим, есть ли простое представление
print("\nПоиск простого представления:")

# Возможные формы
candidates = [
    ("1", 1),
    ("1 - 1/π²", float(1 - 1/pi**2)),
    ("1 - 1/(2π²)", float(1 - 1/(2*pi**2))),
    ("π²/(π²+1)", float(pi**2/(pi**2+1))),
    ("1 - 1/S_geo", float(1 - 1/S_geo)),
    ("1 - 1/24", float(1 - 1/24)),
    ("1 - α", float(1 - 1/S_geo)),
    ("cos(1/π)", float(mp.cos(1/pi))),
    ("1 - 1/137", float(1 - 1/137)),
    ("(24-1)/24", float(23/24)),
    ("exp(-1/S_geo)", float(exp(-1/S_geo))),
    ("1 - 1/(π²·24)", float(1 - 1/(pi**2 * 24))),
]

for name, val in candidates:
    diff_pct = (val - C_opt) / C_opt * 100
    print(f"  {name:20s} = {val:.10f}  (diff: {diff_pct:+.4f}%)")

# =============================================================================
# §7. ЛУЧШИЙ КАНДИДАТ
# =============================================================================

print("\n§7. Лучший кандидат")
print("-"*40)

# Найдём ближайший
best_name, best_val = min(candidates, key=lambda x: abs(x[1] - C_opt))
print(f"Ближайший: {best_name} = {best_val:.10f}")
print(f"C_opt = {C_opt:.10f}")
print(f"Разница: {(best_val - C_opt)*100:.6f}%")

# Но C = 1 всё равно даёт хороший результат
delta_C1 = 1 / (pi**4 * S_geo**2)
alpha_C1 = S_geo - delta_24 - delta_C1
diff_C1 = (alpha_C1 - alpha_codata) / sigma
print(f"\nС C=1: отклонение = {float(diff_C1):.2f}σ")
print("→ Всё ещё в пределах экспериментальной ошибки!")

# =============================================================================
# §8. ГИПОТЕЗА: C = 1 − δ_rad
# =============================================================================

print("\n§8. Гипотеза: радиационные поправки")
print("-"*40)

# В реальной QED есть поправки O(α)
alpha_qed = 1/S_geo
delta_rad = alpha_qed / pi  # типичная 1-loop QED поправка

C_corrected = 1 - delta_rad
print(f"α/π = {float(delta_rad):.10f}")
print(f"C = 1 - α/π = {float(C_corrected):.10f}")
print(f"C_opt = {C_opt:.10f}")
print(f"Разница: {float((C_corrected - C_opt)*100):.4f}%")

# Лучше! Но не точно
# Попробуем другие комбинации
delta_rad2 = alpha_qed / (2*pi)
C_corrected2 = 1 - delta_rad2
print(f"\nC = 1 - α/(2π) = {float(C_corrected2):.10f}")
print(f"Разница: {float((C_corrected2 - C_opt)*100):.4f}%")

# Ещё варианты
delta_rad3 = 1 / (pi * S_geo)
C_corrected3 = 1 - delta_rad3
print(f"\nC = 1 - 1/(π·S) = {float(C_corrected3):.10f}")
print(f"Разница: {float((C_corrected3 - C_opt)*100):.4f}%")

# =============================================================================
# §9. ИТОГ
# =============================================================================

print("\n" + "="*70)
print("ИТОГ")
print("="*70)

print(f"""
1. Оптимальный коэффициент: C_opt = {C_opt:.10f}
   Отклонение от 1: {(C_opt - 1)*100:.4f}%

2. С C = 1: отклонение = {float(diff_C1):.2f}σ
   → В пределах экспериментальной точности!

3. Возможные интерпретации:
   - C = 1 — естественный выбор (безразмерная единица)
   - C ≈ 1 - α/π — радиационная поправка
   - C = Vol(RP³)²/π⁴ = 1 — геометрическое тождество

4. ЧЕСТНЫЙ СТАТУС:
   - C = 1 работает с точностью 0.64%
   - Строгий вывод требует 2-loop вычисления на L(2,1)×S¹
   - Для физиков: "C = 1 — естественный выбор, дающий −0.04σ"
""")

# =============================================================================
# §10. ФИНАЛЬНАЯ ПРОВЕРКА
# =============================================================================

print("\n§10. Финальная формула")
print("-"*40)

alpha_final = S_geo - 1/(24*S_geo) - 1/(pi**4 * S_geo**2)
print(f"α⁻¹ = S_geo - 1/(24·S) - 1/(π⁴·S²)")
print(f"    = {float(S_geo):.12f}")
print(f"    - {float(1/(24*S_geo)):.15e}")
print(f"    - {float(1/(pi**4*S_geo**2)):.15e}")
print(f"    = {float(alpha_final):.15f}")
print(f"\nCODATA = {float(alpha_codata):.15f}")
print(f"Отклонение = {float((alpha_final - alpha_codata)/sigma):.2f}σ")

print("="*70)
